<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Map Editor</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-distortableimage/dist/leaflet.distortableimage.css"/>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF.js -->
    <script src="https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = `https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.worker.min.js`;</script>
    <style>
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
        #map { height: 100%; width: 100%; background-color: #f0f0f0; }
        #map.add-mode-cursor { cursor: crosshair !important; }
        .leaflet-marker-icon.temp-marker { filter: hue-rotate(150deg) brightness(1.2); }
        .modal-backdrop { background-color: rgba(0,0,0,0.5); }
        #connection-status { position: fixed; bottom: 10px; right: 10px; z-index: 1001; padding: 5px 10px; border-radius: 12px; font-size: 12px; font-weight: bold; color: white; transition: background-color 0.3s; }
        #connection-status.connected { background-color: #22c55e; }
        #connection-status.disconnected { background-color: #ef4444; }
        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 10000; display: flex; align-items: center; justify-content: center; color: white; font-size: 1.2rem; display: none; }
    </style>
</head>
<body class="bg-gray-100">
    <div id="loading-overlay">Пожалуйста, подождите...</div>
    <div class="flex h-screen">
        <!-- Left Panel: Controls -->
        <div class="w-1/3 max-w-sm bg-white p-4 shadow-lg overflow-y-auto flex flex-col">
            <h1 class="text-xl font-bold text-gray-800 mb-4">Dynamic Map Editor</h1>
            
            <!-- Project Actions -->
            <div class="space-y-2">
                <button id="settingsBtn" class="w-full bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-4 rounded-lg">Настройки проекта</button>
                <input type="file" id="planUploader" accept="image/svg+xml,application/pdf" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"/>
            </div>

            <hr class="my-4">

            <!-- Plan Actions -->
            <div id="planActions" class="space-y-2 hidden">
                 <button id="adjustPlanBtn" class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg">Настроить положение плана</button>
                 <button id="lockPlanBtn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg hidden">Закрепить положение плана</button>
            </div>
            
            <hr class="my-4">

            <!-- Points Section -->
            <div>
                <h2 class="text-lg font-semibold text-gray-800">Точки на карте</h2>
                <button id="addPointBtn" class="mt-2 w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 disabled:bg-gray-400" disabled>Добавить точку</button>
                <div id="pointEditorContainer" class="mt-4"></div>
            </div>
            
            <div class="flex-grow flex flex-col min-h-0 mt-4">
                 <div id="pointListContainer" class="flex-grow overflow-y-auto bg-gray-50 border rounded-lg p-2 mt-2">
                    <p class="text-center text-gray-500">Нет точек для отображения.</p>
                </div>
            </div>

        </div>

        <!-- Center: Map -->
        <div class="flex-grow bg-gray-200">
            <div id="map"></div>
        </div>
    </div>

    <!-- Connection Status -->
    <div id="connection-status" class="disconnected">Подключение...</div>
    
    <!-- Settings Modal -->
    <div id="settingsModal" class="fixed inset-0 z-50 items-center justify-center hidden">
        <div class="modal-backdrop fixed inset-0"></div>
        <div class="bg-white rounded-lg shadow-xl m-4 sm:max-w-xl sm:w-full relative max-h-[90vh] flex flex-col">
            <div class="p-4 border-b">
                <h3 class="text-lg leading-6 font-medium text-gray-900">Настройки проекта</h3>
            </div>
            <div class="p-4 overflow-y-auto">
                <h4 class="font-semibold text-gray-800 mb-2">Конструктор полей для точек</h4>
                <div id="schemaBuilder" class="space-y-3"></div>
                <button id="addFieldBtn" class="mt-3 text-sm bg-blue-100 text-blue-700 hover:bg-blue-200 font-bold py-1 px-3 rounded-lg">+ Добавить поле</button>
            </div>
            <div class="p-4 border-t bg-gray-50 flex justify-end gap-3">
                 <button id="closeSettingsBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg">Закрыть</button>
                 <button id="saveSettingsBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Сохранить настройки</button>
            </div>
        </div>
    </div>

    <!-- Leaflet JS & Plugins -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-distortableimage/dist/leaflet.distortableimage.js"></script>
    
    <script>
        // --- GLOBAL STATE ---
        let map, geojsonLayer, planOverlay;
        let project = { id: 'default', point_schema: [] };
        let geojsonData = { type: "FeatureCollection", features: [] };
        
        // --- CONSTANTS ---
        const API_HOST = window.location.origin;
        const WS_HOST = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}`;
        const VANCOUVER_COORDS = [49.2827, -123.1207];

        // --- UI ELEMENTS ---
        const ui = {
            loadingOverlay: document.getElementById('loading-overlay'),
            connectionStatus: document.getElementById('connection-status'),
            settingsBtn: document.getElementById('settingsBtn'),
            planUploader: document.getElementById('planUploader'),
            planActions: document.getElementById('planActions'),
            adjustPlanBtn: document.getElementById('adjustPlanBtn'),
            lockPlanBtn: document.getElementById('lockPlanBtn'),
            addPointBtn: document.getElementById('addPointBtn'),
            pointEditorContainer: document.getElementById('pointEditorContainer'),
            pointListContainer: document.getElementById('pointListContainer'),
            settingsModal: document.getElementById('settingsModal'),
            schemaBuilder: document.getElementById('schemaBuilder'),
            addFieldBtn: document.getElementById('addFieldBtn'),
            closeSettingsBtn: document.getElementById('closeSettingsBtn'),
            saveSettingsBtn: document.getElementById('saveSettingsBtn'),
            map: document.getElementById('map')
        };
        
        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', async () => {
            initMap();
            await loadProject();
            setupWebSocket();
            setupEventListeners();
        });

        function initMap() {
            map = L.map('map').setView(VANCOUVER_COORDS, 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap'
            }).addTo(map);
        }
        
        // --- DATA & SERVER COMMUNICATION ---
        async function loadProject() {
            try {
                const response = await fetch(`${API_HOST}/api/project`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                handleProjectUpdate(data);
            } catch (error) {
                console.error('Error loading project:', error);
                alert('Не удалось загрузить проект с сервера.');
            }
        }
        
        async function sendSettings(settings) {
            try {
                const response = await fetch(`${API_HOST}/api/project/settings`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });
                if (!response.ok) throw new Error('Failed to save settings');
            } catch (err) {
                alert('Ошибка сохранения настроек: ' + err.message);
            }
        }

        // --- MAP & PLAN LOGIC ---
        function renderPlan() {
            if (planOverlay) {
                planOverlay.remove();
                planOverlay = null;
            }
            if (project.plan_data_url) {
                const corners = project.plan_corners ? project.plan_corners.map(c => L.latLng(c.lat, c.lng)) : null;
                planOverlay = L.distortableImageOverlay(project.plan_data_url, { corners }).addTo(map);
                ui.planActions.classList.remove('hidden');
                ui.addPointBtn.disabled = false;
                if (!project.plan_corners) { // If not positioned, fit to view
                    map.setView(VANCOUVER_COORDS, 15);
                }
            } else {
                ui.planActions.classList.add('hidden');
                ui.addPointBtn.disabled = true;
            }
        }

        // --- DYNAMIC FORM BUILDER ---
        function renderPointEditor(featureId = null) {
            let feature = null;
            if (featureId) {
                feature = geojsonData.features.find(f => f.properties.id === featureId);
            }

            ui.pointEditorContainer.innerHTML = ''; // Clear previous form
            const form = document.createElement('form');
            form.className = 'panel border p-3 rounded-lg bg-gray-50';
            
            const title = document.createElement('p');
            title.className = 'text-md font-semibold text-center text-blue-800 p-2 rounded-lg';
            title.textContent = featureId ? `Редактирование точки` : 'Новая точка';
            form.appendChild(title);

            // Generate fields from schema
            (project.point_schema || []).forEach(field => {
                const value = feature ? feature.properties[field.name] : '';
                form.appendChild(createFormField(field, value));
            });

            const saveBtn = document.createElement('button');
            saveBtn.type = 'submit';
            saveBtn.className = 'w-full mt-4 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg';
            saveBtn.textContent = 'Сохранить';
            form.appendChild(saveBtn);
            
            const cancelBtn = document.createElement('button');
            cancelBtn.type = 'button';
            cancelBtn.className = 'w-full mt-2 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg';
            cancelBtn.textContent = 'Отмена';
            cancelBtn.onclick = () => { ui.pointEditorContainer.innerHTML = ''; };
            form.appendChild(cancelBtn);

            form.onsubmit = async (e) => {
                e.preventDefault();
                await savePointFromForm(form, featureId);
            };

            ui.pointEditorContainer.appendChild(form);
        }

        function createFormField(field, value) {
            const container = document.createElement('div');
            container.className = 'mt-3';
            const label = document.createElement('label');
            label.textContent = field.name;
            label.className = 'block text-sm font-medium text-gray-700';
            container.appendChild(label);
            
            let input;
            switch(field.type) {
                case 'select':
                    input = document.createElement('select');
                    (field.options || []).forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt;
                        option.textContent = opt;
                        if (opt === value) option.selected = true;
                        input.appendChild(option);
                    });
                    break;
                case 'textarea':
                    input = document.createElement('textarea');
                    input.rows = 3;
                    input.value = value || '';
                    break;
                case 'image':
                     input = document.createElement('input');
                     input.type = 'file';
                     input.accept = 'image/*';
                     input.dataset.currentImage = value || ''; // Store current image URL
                     if (value) {
                         const preview = document.createElement('img');
                         preview.src = value;
                         preview.className = 'w-16 h-16 mt-1 object-cover rounded';
                         container.appendChild(preview);
                     }
                     break;
                default: // text, color, date etc.
                    input = document.createElement('input');
                    input.type = field.type;
                    input.value = value || '';
            }
            input.id = `field-${field.name}`;
            input.name = field.name;
            input.className = 'mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm';
            container.appendChild(input);
            return container;
        }

        async function savePointFromForm(form, featureId) {
            const properties = { id: featureId || `feature-${Date.now()}` };
            let geometry;

            for (const field of project.point_schema) {
                const input = form.querySelector(`[name="${field.name}"]`);
                if (field.type === 'image') {
                    if (input.files && input.files[0]) {
                        properties[field.name] = await getFileDataUrl(input.files[0]);
                    } else {
                        properties[field.name] = input.dataset.currentImage || null;
                    }
                } else {
                    properties[field.name] = input.value;
                }
            }

            if (featureId) {
                geometry = geojsonData.features.find(f => f.properties.id === featureId).geometry;
            } else {
                const center = map.getCenter();
                geometry = { type: 'Point', coordinates: [center.lng, center.lat] };
            }
            
            const feature = { type: "Feature", properties, geometry };
            // Await is important here
            await fetch(`${API_HOST}/api/points`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(feature)
            });
            ui.pointEditorContainer.innerHTML = '';
        }

        // --- EVENT LISTENERS & HANDLERS ---
        function setupEventListeners() {
            ui.planUploader.addEventListener('change', handlePlanUpload);
            ui.settingsBtn.addEventListener('click', openSettingsModal);
            ui.closeSettingsBtn.addEventListener('click', closeSettingsModal);
            ui.saveSettingsBtn.addEventListener('click', saveSettings);
            ui.addFieldBtn.addEventListener('click', addSchemaField);
            ui.adjustPlanBtn.addEventListener('click', () => {
                planOverlay.editing.enable();
                ui.adjustPlanBtn.classList.add('hidden');
                ui.lockPlanBtn.classList.remove('hidden');
            });
            ui.lockPlanBtn.addEventListener('click', async () => {
                planOverlay.editing.disable();
                const corners = planOverlay.getCorners();
                await sendSettings({ plan_corners: corners });
                ui.adjustPlanBtn.classList.remove('hidden');
                ui.lockPlanBtn.classList.add('hidden');
            });
            ui.addPointBtn.addEventListener('click', () => renderPointEditor());
        }

        async function handlePlanUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            ui.loadingOverlay.style.display = 'flex';
            try {
                const { dataUrl, dimensions } = file.type === 'application/pdf' 
                    ? await renderPdfToDataUrl(file)
                    : { dataUrl: await getFileDataUrl(file), dimensions: await getImageDimensions(await getFileDataUrl(file)) };
                
                const response = await fetch(`${API_HOST}/api/project/plan`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ planDataUrl: dataUrl, width: dimensions.width, height: dimensions.height })
                });
                if (!response.ok) throw new Error(await response.text());
            } catch(err) { 
                alert(`Ошибка загрузки плана: ${err.message}`);
            } finally {
                ui.loadingOverlay.style.display = 'none';
                ui.planUploader.value = '';
            }
        }
        
        function handleProjectUpdate(data) {
             project = data.project;
             geojsonData = data.geojsonData;
             if (!project.point_schema) project.point_schema = []; // Ensure schema exists
             renderPlan();
             renderPoints();
             renderPointList();
        }

        function renderPoints() {
            if (geojsonLayer) geojsonLayer.remove();
            geojsonLayer = L.geoJSON(geojsonData, {
                 pointToLayer: (feature, latlng) => L.circleMarker(latlng, {
                    radius: 8,
                    fillColor: feature.properties.Color || "#3388ff",
                    color: "#000", weight: 1, opacity: 1, fillOpacity: 0.8
                }),
                onEachFeature: (feature, layer) => {
                    layer.on('click', (e) => {
                        L.DomEvent.stopPropagation(e);
                        renderPointEditor(feature.properties.id);
                    });
                }
            }).addTo(map);
        }
        
        function renderPointList() {
            ui.pointListContainer.innerHTML = '';
            if (geojsonData.features.length === 0) {
                ui.pointListContainer.innerHTML = '<p class="text-center text-gray-500">Нет точек для отображения.</p>';
                return;
            }
            geojsonData.features.forEach(f => {
                const item = document.createElement('div');
                item.className = 'flex items-center p-2 rounded hover:bg-gray-100 cursor-pointer';
                const colorField = project.point_schema.find(field => field.type === 'color');
                const color = colorField ? f.properties[colorField.name] : '#cccccc';

                item.innerHTML = `
                    <div class="w-4 h-4 rounded-full mr-3" style="background-color: ${color}"></div>
                    <span>${f.properties.Name || f.properties.name || 'Без названия'}</span>
                `;
                item.onclick = () => map.flyTo([f.geometry.coordinates[1], f.geometry.coordinates[0]], 18);
                ui.pointListContainer.appendChild(item);
            });
        }
        
        // --- SETTINGS MODAL ---
        function openSettingsModal() {
            renderSchemaBuilder();
            ui.settingsModal.style.display = 'flex';
        }
        function closeSettingsModal() { ui.settingsModal.style.display = 'none'; }
        
        function renderSchemaBuilder() {
            ui.schemaBuilder.innerHTML = '';
            (project.point_schema || []).forEach((field, index) => {
                ui.schemaBuilder.appendChild(createSchemaFieldRow(field, index));
            });
        }

        function createSchemaFieldRow(field, index) {
            const div = document.createElement('div');
            div.className = 'grid grid-cols-3 gap-2 items-center p-2 border rounded';
            div.innerHTML = `
                <input type="text" value="${field.name}" placeholder="Название поля" class="col-span-1 p-1 border rounded schema-name">
                <select class="col-span-1 p-1 border rounded schema-type">
                    <option value="text" ${field.type === 'text' ? 'selected' : ''}>Текст</option>
                    <option value="textarea" ${field.type === 'textarea' ? 'selected' : ''}>Длинный текст</option>
                    <option value="select" ${field.type === 'select' ? 'selected' : ''}>Выпадающий список</option>
                    <option value="color" ${field.type === 'color' ? 'selected' : ''}>Цвет</option>
                    <option value="date" ${field.type === 'date' ? 'selected' : ''}>Дата</option>
                    <option value="image" ${field.type === 'image' ? 'selected' : ''}>Изображение</option>
                </select>
                <div class="flex items-center">
                    <input type="text" value="${(field.options || []).join(',')}" placeholder="Опции (через запятую)" class="flex-grow p-1 border rounded schema-options ${field.type !== 'select' ? 'hidden' : ''}">
                    <button data-index="${index}" class="ml-2 text-red-500 hover:text-red-700 remove-field-btn">&times;</button>
                </div>
            `;
            div.querySelector('.schema-type').onchange = (e) => {
                div.querySelector('.schema-options').classList.toggle('hidden', e.target.value !== 'select');
            };
            div.querySelector('.remove-field-btn').onclick = (e) => {
                project.point_schema.splice(e.target.dataset.index, 1);
                renderSchemaBuilder();
            };
            return div;
        }

        function addSchemaField() {
            if (!project.point_schema) project.point_schema = [];
            project.point_schema.push({ name: '', type: 'text', options: [] });
            renderSchemaBuilder();
        }

        async function saveSettings() {
            const newSchema = [];
            document.querySelectorAll('#schemaBuilder > div').forEach(row => {
                const name = row.querySelector('.schema-name').value.trim();
                const type = row.querySelector('.schema-type').value;
                const options = row.querySelector('.schema-options').value.split(',').map(s => s.trim()).filter(Boolean);
                if (name) {
                    newSchema.push({ name, type, options });
                }
            });
            await sendSettings({ point_schema: newSchema });
            project.point_schema = newSchema;
            closeSettingsModal();
        }
        
        // --- WEBSOCKET HANDLING ---
        function setupWebSocket() {
            const ws = new WebSocket(WS_HOST);
            ws.onopen = () => { ui.connectionStatus.textContent = 'Подключено'; ui.connectionStatus.className = 'connected'; };
            ws.onmessage = (event) => handleWebSocketMessage(JSON.parse(event.data));
            ws.onclose = () => { ui.connectionStatus.textContent = 'Отключено'; ui.connectionStatus.className = 'disconnected'; setTimeout(setupWebSocket, 3000); };
            ws.onerror = () => ws.close();
        }
        
        function handleWebSocketMessage(message) {
            switch(message.type) {
                case 'point_update':
                    const index = geojsonData.features.findIndex(f => f.properties.id === message.payload.properties.id);
                    if (index > -1) geojsonData.features[index] = message.payload;
                    else geojsonData.features.push(message.payload);
                    renderPoints();
                    renderPointList();
                    break;
                case 'point_delete':
                    geojsonData.features = geojsonData.features.filter(f => f.properties.id !== message.payload.id);
                    renderPoints();
                    renderPointList();
                    break;
                case 'plan_update':
                case 'project_import':
                case 'settings_update':
                     loadProject(); // Simplest way to get all changes
                    break;
            }
        }

        // --- UTILITY FUNCTIONS ---
        function getFileDataUrl(file) { return new Promise((res, rej) => { if (!file) return res(null); const r = new FileReader(); r.onload = () => res(r.result); r.onerror = rej; r.readAsDataURL(file); }); }
        function getImageDimensions(src) { return new Promise((res, rej) => { const i = new Image(); i.onload = () => res({width: i.width, height: i.height}); i.onerror = rej; i.src = src; }); }
        async function renderPdfToDataUrl(file) { const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise; const page = await pdf.getPage(1); const viewport = page.getViewport({ scale: 2.0 }); const canvas = document.createElement('canvas'); canvas.height = viewport.height; canvas.width = viewport.width; await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise; return { dataUrl: canvas.toDataURL(), dimensions: { width: canvas.width, height: canvas.height } }; }
    </script>
</body>
</html>

