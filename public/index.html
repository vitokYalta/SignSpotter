<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Map Editor</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"/>
    <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.css"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-distortableimage/dist/leaflet.distortableimage.css"/>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF.js -->
    <script src="https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.worker.min.js`;
    </script>
    <style>
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
        #map { height: 100%; width: 100%; background-color: #f0f0f0; }
        #map.add-mode-cursor { cursor: crosshair !important; }
        .leaflet-marker-icon.temp-marker { filter: hue-rotate(150deg) brightness(1.2); }
        #connection-status { position: fixed; bottom: 10px; right: 10px; z-index: 1001; padding: 5px 10px; border-radius: 12px; font-size: 12px; font-weight: bold; color: white; transition: background-color 0.3s; }
        #connection-status.connected { background-color: #22c55e; }
        #connection-status.disconnected { background-color: #ef4444; }
        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 10000; display: flex; align-items: center; justify-content: center; color: white; font-size: 1.2rem; display: none; }
        .leaflet-distortable-image-handle { background-color: rgba(255, 255, 0, 0.8) !important; border: 2px solid #333 !important; }
        .leaflet-control-geolocation { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23333' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 2L7 22l10-5-5-10z'/%3E%3C/svg%3E"); background-size: 18px 18px; background-repeat: no-repeat; background-position: center; }
    </style>
</head>
<body class="bg-gray-100">
    <div id="loading-overlay">Please wait...</div>
    <div class="flex h-screen">
        <!-- Left Panel: Controls -->
        <div class="w-1/3 max-w-sm bg-white p-4 shadow-lg overflow-y-auto flex flex-col">
            <h1 class="text-xl font-bold text-gray-800 mb-4">Dynamic Map Editor</h1>
            
            <!-- Project Actions -->
            <div class="space-y-2">
                <button id="settingsBtn" class="w-full bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-4 rounded-lg">Project Settings</button>
                <input type="file" id="planUploader" accept="image/svg+xml,application/pdf" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"/>
            </div>

            <hr class="my-4">

            <!-- Plan Actions -->
            <div id="planActions" class="space-y-2 hidden">
                 <button id="adjustPlanBtn" class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg">Adjust Plan Position</button>
                 <button id="lockPlanBtn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg hidden">Lock Plan</button>
            </div>
            
            <hr class="my-4">

            <!-- Points Section -->
            <div>
                <h2 class="text-lg font-semibold text-gray-800">Map Points</h2>
                <button id="addPointBtn" class="mt-2 w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 disabled:bg-gray-400" disabled>Add Point</button>
                <div id="pointEditorContainer" class="mt-4"></div>
            </div>
            
            <div class="flex-grow flex flex-col min-h-0 mt-4">
                 <div id="pointListContainer" class="flex-grow overflow-y-auto bg-gray-50 border rounded-lg p-2 mt-2">
                    <p class="text-center text-gray-500">No points to display.</p>
                </div>
            </div>

        </div>

        <!-- Center: Map -->
        <div class="flex-grow bg-gray-200">
            <div id="map"></div>
        </div>
    </div>

    <!-- Connection Status -->
    <div id="connection-status" class="disconnected">Connecting...</div>
    
    <!-- Settings Modal -->
    <div id="settingsModal" class="fixed inset-0 z-[1000] flex items-center justify-center hidden">
        <!-- Backdrop -->
        <div id="modalBackdrop" class="fixed inset-0 bg-black bg-opacity-50"></div>
        <!-- Modal Content -->
        <div class="bg-white rounded-lg shadow-xl m-4 sm:max-w-xl sm:w-full relative z-10 max-h-[90vh] flex flex-col">
            <div class="p-4 border-b">
                <h3 class="text-lg leading-6 font-medium text-gray-900">Project Settings</h3>
            </div>
            <div class="p-4 overflow-y-auto">
                <h4 class="font-semibold text-gray-800 mb-2">Point Field Builder</h4>
                <div id="schemaBuilder" class="space-y-3"></div>
                <button id="addFieldBtn" class="mt-3 text-sm bg-blue-100 text-blue-700 hover:bg-blue-200 font-bold py-1 px-3 rounded-lg">+ Add Field</button>
            </div>
            <div class="p-4 border-t bg-gray-50 flex justify-end gap-3">
                 <button id="closeSettingsBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg">Close</button>
                 <button id="saveSettingsBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Save Settings</button>
            </div>
        </div>
    </div>

    <!-- Leaflet JS & Plugins (Order is important) -->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.min.js"></script>
    <script src="https://unpkg.com/leaflet-distortableimage/dist/leaflet.distortableimage.js"></script>
    
    <script>
        // --- GLOBAL STATE ---
        let map, geojsonLayer, planOverlay, userLocationMarker;
        let project = { id: 'default', point_schema: [] };
        let geojsonData = { type: "FeatureCollection", features: [] };
        
        // --- CONSTANTS ---
        const IS_PREVIEW = !window.location.host;
        const WS_HOST = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}`;
        const VANCOUVER_COORDS = [49.2827, -123.1207];

        // --- UI ELEMENTS ---
        const ui = {
            loadingOverlay: document.getElementById('loading-overlay'),
            connectionStatus: document.getElementById('connection-status'),
            settingsBtn: document.getElementById('settingsBtn'),
            planUploader: document.getElementById('planUploader'),
            planActions: document.getElementById('planActions'),
            adjustPlanBtn: document.getElementById('adjustPlanBtn'),
            lockPlanBtn: document.getElementById('lockPlanBtn'),
            addPointBtn: document.getElementById('addPointBtn'),
            pointEditorContainer: document.getElementById('pointEditorContainer'),
            pointListContainer: document.getElementById('pointListContainer'),
            settingsModal: document.getElementById('settingsModal'),
            modalBackdrop: document.getElementById('modalBackdrop'),
            schemaBuilder: document.getElementById('schemaBuilder'),
            addFieldBtn: document.getElementById('addFieldBtn'),
            closeSettingsBtn: document.getElementById('closeSettingsBtn'),
            saveSettingsBtn: document.getElementById('saveSettingsBtn'),
            map: document.getElementById('map')
        };
        
        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', async () => {
            initMap();
            await loadProject();
            if (!IS_PREVIEW) {
                setupWebSocket();
            } else {
                ui.connectionStatus.textContent = 'Real-time disabled';
                ui.connectionStatus.className = 'disconnected';
            }
            setupEventListeners();
        });

        function initMap() {
            map = L.map('map', { maxZoom: 22 }).setView(VANCOUVER_COORDS, 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap'
            }).addTo(map);

            // Add Geolocation control
            L.Control.Geolocation = L.Control.extend({
                onAdd: function(map) {
                    const btn = L.DomUtil.create('a', 'leaflet-control-geolocation leaflet-bar leaflet-control');
                    btn.title = 'Show my location';
                    btn.href = '#';
                    btn.setAttribute('role', 'button');

                    L.DomEvent.on(btn, 'click', L.DomEvent.stop).on(btn, 'click', function() {
                        if (!("geolocation" in navigator)) {
                            alert("Geolocation is not supported by your browser.");
                            return;
                        }
                        navigator.geolocation.getCurrentPosition(position => {
                            const latlng = [position.coords.latitude, position.coords.longitude];
                            if (userLocationMarker) {
                                userLocationMarker.setLatLng(latlng);
                            } else {
                                userLocationMarker = L.circle(latlng, {
                                    radius: 10,
                                    color: 'blue',
                                    fillColor: '#3498db',
                                    fillOpacity: 0.8
                                }).addTo(map);
                            }
                            map.flyTo(latlng, 18);
                        }, error => {
                            alert(`Geolocation Error: ${error.message}`);
                        });
                    });

                    return btn;
                }
            });
            new L.Control.Geolocation({ position: 'topleft' }).addTo(map);
        }
        
        // --- DATA & SERVER COMMUNICATION ---
        async function loadProject() {
            if (IS_PREVIEW) {
                console.warn("Running in preview mode. API calls are disabled.");
                handleProjectUpdate({ project: { id: 'preview', point_schema: [{name: 'Name', type: 'text'}, {name: 'Status', type: 'select', options:['Open', 'Closed']}] }, geojsonData: { type: "FeatureCollection", features: [] } });
                return;
            }
            try {
                const response = await fetch('/api/project');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                handleProjectUpdate(data);
            } catch (error) {
                console.error('Error loading project:', error);
                alert('Failed to load project from server.');
            }
        }
        
        async function sendSettings(settings) {
            if (IS_PREVIEW) { return alert("This feature is disabled in preview mode."); }
            try {
                const response = await fetch('/api/project/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });
                if (!response.ok) throw new Error('Failed to save settings');
            } catch (err) {
                alert('Error saving settings: ' + err.message);
            }
        }

        // --- MAP & PLAN LOGIC ---
        function renderPlan() {
            if (planOverlay) {
                planOverlay.remove();
                planOverlay = null;
            }
            if (project.plan_data_url) {
                const corners = project.plan_corners ? project.plan_corners.map(c => L.latLng(c.lat, c.lng)) : null;
                planOverlay = L.distortableImageOverlay(project.plan_data_url, { corners }).addTo(map);
                ui.planActions.classList.remove('hidden');
                ui.addPointBtn.disabled = false;
                if (!project.plan_corners) { 
                     map.setView(VANCOUVER_COORDS, 15);
                }
            } else {
                ui.planActions.classList.add('hidden');
                ui.addPointBtn.disabled = true;
            }
        }

        // --- DYNAMIC FORM BUILDER ---
        function renderPointEditor(featureId = null) {
            let feature = null;
            if (featureId) {
                feature = geojsonData.features.find(f => f.properties.id === featureId);
            }

            ui.pointEditorContainer.innerHTML = ''; // Clear previous form
            const form = document.createElement('form');
            form.className = 'panel border p-3 rounded-lg bg-gray-50';
            
            const title = document.createElement('p');
            title.className = 'text-md font-semibold text-center text-blue-800 p-2 rounded-lg';
            title.textContent = featureId ? 'Editing Point' : 'New Point';
            form.appendChild(title);

            // Generate fields from schema
            (project.point_schema || []).forEach(field => {
                const value = feature ? feature.properties[field.name] : '';
                form.appendChild(createFormField(field, value));
            });

            const saveBtn = document.createElement('button');
            saveBtn.type = 'submit';
            saveBtn.className = 'w-full mt-4 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg';
            saveBtn.textContent = 'Save';
            form.appendChild(saveBtn);
            
            const cancelBtn = document.createElement('button');
            cancelBtn.type = 'button';
            cancelBtn.className = 'w-full mt-2 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => { ui.pointEditorContainer.innerHTML = ''; };
            form.appendChild(cancelBtn);

            form.onsubmit = async (e) => {
                e.preventDefault();
                await savePointFromForm(form, featureId);
            };

            ui.pointEditorContainer.appendChild(form);
        }

        function createFormField(field, value) {
            const container = document.createElement('div');
            container.className = 'mt-3';
            const label = document.createElement('label');
            label.textContent = field.name;
            label.className = 'block text-sm font-medium text-gray-700';
            container.appendChild(label);
            
            let input;
            switch(field.type) {
                case 'select':
                    input = document.createElement('select');
                    (field.options || []).forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt;
                        option.textContent = opt;
                        if (opt === value) option.selected = true;
                        input.appendChild(option);
                    });
                    break;
                case 'textarea':
                    input = document.createElement('textarea');
                    input.rows = 3;
                    input.value = value || '';
                    break;
                case 'image':
                     input = document.createElement('input');
                     input.type = 'file';
                     input.accept = 'image/*';
                     input.dataset.currentImage = value || ''; // Store current image URL
                     if (value) {
                         const preview = document.createElement('img');
                         preview.src = value;
                         preview.className = 'w-16 h-16 mt-1 object-cover rounded';
                         container.appendChild(preview);
                     }
                     break;
                default: // text, color, date etc.
                    input = document.createElement('input');
                    input.type = field.type;
                    input.value = value || '';
            }
            input.id = `field-${field.name}`;
            input.name = field.name;
            input.className = 'mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm';
            container.appendChild(input);
            return container;
        }

        async function savePointFromForm(form, featureId) {
            if (IS_PREVIEW) { return alert("This feature is disabled in preview mode."); }
            const properties = { id: featureId || `feature-${Date.now()}` };
            let geometry;

            for (const field of project.point_schema) {
                const input = form.querySelector(`[name="${field.name}"]`);
                if (field.type === 'image') {
                    if (input.files && input.files[0]) {
                        properties[field.name] = await getFileDataUrl(input.files[0]);
                    } else {
                        properties[field.name] = input.dataset.currentImage || null;
                    }
                } else {
                    properties[field.name] = input.value;
                }
            }

            if (featureId) {
                geometry = geojsonData.features.find(f => f.properties.id === featureId).geometry;
            } else {
                const center = map.getCenter();
                geometry = { type: 'Point', coordinates: [center.lng, center.lat] };
            }
            
            const feature = { type: "Feature", properties, geometry };
            
            await fetch('/api/points', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(feature)
            });
            ui.pointEditorContainer.innerHTML = '';
        }

        // --- EVENT LISTENERS & HANDLERS ---
        function setupEventListeners() {
            ui.planUploader.addEventListener('change', handlePlanUpload);
            ui.settingsBtn.addEventListener('click', openSettingsModal);
            ui.modalBackdrop.addEventListener('click', closeSettingsModal);
            ui.closeSettingsBtn.addEventListener('click', closeSettingsModal);
            ui.saveSettingsBtn.addEventListener('click', saveSettings);
            ui.addFieldBtn.addEventListener('click', addSchemaField);
            ui.adjustPlanBtn.addEventListener('click', () => {
                if (planOverlay) {
                    planOverlay.editing.enable();
                    ui.adjustPlanBtn.classList.add('hidden');
                    ui.lockPlanBtn.classList.remove('hidden');
                }
            });
            ui.lockPlanBtn.addEventListener('click', async () => {
                if (planOverlay) {
                    planOverlay.editing.disable();
                    const corners = planOverlay.getCorners();
                    await sendSettings({ plan_corners: corners });
                    ui.adjustPlanBtn.classList.remove('hidden');
                    ui.lockPlanBtn.classList.add('hidden');
                }
            });
            ui.addPointBtn.addEventListener('click', () => renderPointEditor());
        }

        async function handlePlanUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            if (file.size > 25 * 1024 * 1024) { // Client-side size check for stability
                alert("File is too large. Please select a file smaller than 25MB.");
                ui.planUploader.value = '';
                return;
            }

            if (IS_PREVIEW) { return alert("This feature is disabled in preview mode."); }

            ui.loadingOverlay.textContent = 'Processing file...';
            ui.loadingOverlay.style.display = 'flex';
            
            try {
                let dataUrl, dimensions;
                
                console.log("Starting file processing...");
                if (file.type === 'application/pdf') {
                    ui.loadingOverlay.textContent = 'Rendering PDF (this may take a moment)...';
                    const pdfData = await renderPdfToDataUrl(file);
                    dataUrl = pdfData.dataUrl;
                    dimensions = pdfData.dimensions;
                } else {
                    ui.loadingOverlay.textContent = 'Reading image...';
                    dataUrl = await getFileDataUrl(file);
                    dimensions = await getImageDimensions(dataUrl);
                }
                console.log("File processed into data URL.");

                ui.loadingOverlay.textContent = 'Uploading to server...';
                
                const response = await fetch('/api/project/plan', {
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ planDataUrl: dataUrl, width: dimensions.width, height: dimensions.height })
                });
                
                console.log("Server response status:", response.status);

                if (!response.ok) {
                    // Try to parse error message from server, otherwise use status text
                    let errorMsg = `Server responded with status ${response.status}`;
                    try {
                        const errorData = await response.json();
                        errorMsg = errorData.message || errorMsg;
                    } catch (parseErr) {
                        // Ignore if response is not json
                    }
                    throw new Error(errorMsg);
                }
                
                console.log("Upload successful. The map will update shortly via WebSocket.");
                // The server will broadcast 'plan_update', and the client's WebSocket listener will call loadProject().

            } catch(err) { 
                console.error("Error during plan upload:", err);
                alert(`An error occurred while uploading the plan:\n\n${err.message}`);
            } finally {
                ui.loadingOverlay.style.display = 'none';
                ui.planUploader.value = '';
            }
        }
        
        function handleProjectUpdate(data) {
             project = data.project;
             geojsonData = data.geojsonData;
             if (!project.point_schema) project.point_schema = []; // Ensure schema exists
             renderPlan();
             renderPoints();
             renderPointList();
        }

        function renderPoints() {
            if (geojsonLayer) geojsonLayer.remove();
            geojsonLayer = L.geoJSON(geojsonData, {
                 pointToLayer: (feature, latlng) => L.circleMarker(latlng, {
                    radius: 8,
                    fillColor: feature.properties.Color || "#3388ff",
                    color: "#000", weight: 1, opacity: 1, fillOpacity: 0.8
                }),
                onEachFeature: (feature, layer) => {
                    layer.on('click', (e) => {
                        L.DomEvent.stopPropagation(e);
                        renderPointEditor(feature.properties.id);
                    });
                }
            }).addTo(map);
        }
        
        function renderPointList() {
            ui.pointListContainer.innerHTML = '';
            if (geojsonData.features.length === 0) {
                ui.pointListContainer.innerHTML = '<p class="text-center text-gray-500">No points to display.</p>';
                return;
            }
            geojsonData.features.forEach(f => {
                const item = document.createElement('div');
                item.className = 'flex items-center p-2 rounded hover:bg-gray-100 cursor-pointer';
                const colorField = project.point_schema.find(field => field.type === 'color');
                const color = colorField ? (f.properties[colorField.name] || '#cccccc') : '#cccccc';

                const nameField = project.point_schema.find(field => field.name.toLowerCase() === 'name');
                const name = nameField ? (f.properties[nameField.name] || 'Untitled Point') : 'Untitled Point';

                item.innerHTML = `
                    <div class="w-4 h-4 rounded-full mr-3" style="background-color: ${color}"></div>
                    <span>${name}</span>
                `;
                item.onclick = () => map.flyTo([f.geometry.coordinates[1], f.geometry.coordinates[0]], 18);
                ui.pointListContainer.appendChild(item);
            });
        }
        
        // --- SETTINGS MODAL ---
        function openSettingsModal() {
            renderSchemaBuilder();
            ui.settingsModal.classList.remove('hidden');
        }
        function closeSettingsModal() { 
            ui.settingsModal.classList.add('hidden');
        }
        
        function renderSchemaBuilder() {
            ui.schemaBuilder.innerHTML = '';
            (project.point_schema || []).forEach((field, index) => {
                ui.schemaBuilder.appendChild(createSchemaFieldRow(field, index));
            });
        }

        function createSchemaFieldRow(field, index) {
            const div = document.createElement('div');
            div.className = 'grid grid-cols-3 gap-2 items-center p-2 border rounded';
            div.innerHTML = `
                <input type="text" value="${field.name}" placeholder="Field Name" class="col-span-1 p-1 border rounded schema-name">
                <select class="col-span-1 p-1 border rounded schema-type">
                    <option value="text" ${field.type === 'text' ? 'selected' : ''}>Text</option>
                    <option value="textarea" ${field.type === 'textarea' ? 'selected' : ''}>Text Area</option>
                    <option value="select" ${field.type === 'select' ? 'selected' : ''}>Dropdown</option>
                    <option value="color" ${field.type === 'color' ? 'selected' : ''}>Color</option>
                    <option value="date" ${field.type === 'date' ? 'selected' : ''}>Date</option>
                    <option value="image" ${field.type === 'image' ? 'selected' : ''}>Image</option>
                </select>
                <div class="flex items-center">
                    <input type="text" value="${(field.options || []).join(',')}" placeholder="Options (comma-separated)" class="flex-grow p-1 border rounded schema-options ${field.type !== 'select' ? 'hidden' : ''}">
                    <button data-index="${index}" class="ml-2 text-red-500 hover:text-red-700 remove-field-btn text-2xl font-bold">&times;</button>
                </div>
            `;
            div.querySelector('.schema-type').onchange = (e) => {
                div.querySelector('.schema-options').classList.toggle('hidden', e.target.value !== 'select');
            };
            div.querySelector('.remove-field-btn').onclick = (e) => {
                project.point_schema.splice(e.target.dataset.index, 1);
                renderSchemaBuilder();
            };
            return div;
        }

        function addSchemaField() {
            if (!project.point_schema) project.point_schema = [];
            project.point_schema.push({ name: '', type: 'text', options: [] });
            renderSchemaBuilder();
        }

        async function saveSettings() {
            const newSchema = [];
            document.querySelectorAll('#schemaBuilder > div').forEach(row => {
                const name = row.querySelector('.schema-name').value.trim();
                const type = row.querySelector('.schema-type').value;
                const options = row.querySelector('.schema-options').value.split(',').map(s => s.trim()).filter(Boolean);
                if (name) {
                    newSchema.push({ name, type, options });
                }
            });
            await sendSettings({ point_schema: newSchema });
            project.point_schema = newSchema;
            closeSettingsModal();
        }
        
        // --- WEBSOCKET HANDLING ---
        function setupWebSocket() {
            const ws = new WebSocket(WS_HOST);
            ws.onopen = () => { ui.connectionStatus.textContent = 'Connected'; ui.connectionStatus.className = 'connected'; };
            ws.onmessage = (event) => handleWebSocketMessage(JSON.parse(event.data));
            ws.onclose = () => { ui.connectionStatus.textContent = 'Disconnected'; ui.connectionStatus.className = 'disconnected'; setTimeout(setupWebSocket, 3000); };
            ws.onerror = () => ws.close();
        }
        
        function handleWebSocketMessage(message) {
            switch(message.type) {
                case 'point_update':
                    const index = geojsonData.features.findIndex(f => f.properties.id === message.payload.properties.id);
                    if (index > -1) geojsonData.features[index] = message.payload;
                    else geojsonData.features.push(message.payload);
                    renderPoints();
                    renderPointList();
                    break;
                case 'point_delete':
                    geojsonData.features = geojsonData.features.filter(f => f.properties.id !== message.payload.id);
                    renderPoints();
                    renderPointList();
                    break;
                case 'plan_update':
                case 'project_import':
                case 'settings_update':
                     loadProject(); // Simplest way to get all changes
                    break;
            }
        }

        // --- UTILITY FUNCTIONS ---
        function getFileDataUrl(file) { return new Promise((res, rej) => { if (!file) return res(null); const r = new FileReader(); r.onload = () => res(r.result); r.onerror = rej; r.readAsDataURL(file); }); }
        function getImageDimensions(src) { return new Promise((res, rej) => { const i = new Image(); i.onload = () => res({width: i.width, height: i.height}); i.onerror = rej; i.src = src; }); }
        async function renderPdfToDataUrl(file) { 
            const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise; 
            const page = await pdf.getPage(1); 
            const viewport = page.getViewport({ scale: 2.0 }); 
            const canvas = document.createElement('canvas'); 
            canvas.height = viewport.height; 
            canvas.width = viewport.width; 
            await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise; 
            return { dataUrl: canvas.toDataURL(), dimensions: { width: canvas.width, height: canvas.height } }; 
        }
    </script>
</body>
</html>

